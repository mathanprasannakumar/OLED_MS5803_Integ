
#include "ssd1306.h"
#include "spi.h"
#include "delay.h"

// OLED control pin macros
#define OLED_CS_LOW    (P3OUT &= ~BIT0)
#define OLED_CS_HIGH   (P3OUT |=  BIT0)
#define DC_CMD    (P3OUT &= ~BIT7)  // Command mode
#define DC_DATA   (P3OUT |=  BIT7)  // Data mode
#define RES_LOW   (P3OUT &= ~BIT6)
#define RES_HIGH  (P3OUT |=  BIT6)

uint8_t pixel_per_digit = 7;
uint8_t init_page = 4;
uint8_t mid_col = 64;


// font map
const uint8_t font5x7_digits[10][5] = {
    {0x3E, 0x51, 0x49, 0x45, 0x3E}, // '0'
    {0x00, 0x42, 0x7F, 0x40, 0x00}, // '1'
    {0x42, 0x61, 0x51, 0x49, 0x46}, // '2'
    {0x21, 0x41, 0x45, 0x4B, 0x31}, // '3'
    {0x18, 0x14, 0x12, 0x7F, 0x10}, // '4'
    {0x27, 0x45, 0x45, 0x45, 0x39}, // '5'
    {0x3C, 0x4A, 0x49, 0x49, 0x30}, // '6'
    {0x01, 0x71, 0x09, 0x05, 0x03}, // '7'
    {0x36, 0x49, 0x49, 0x49, 0x36}, // '8'
    {0x06, 0x49, 0x49, 0x29, 0x1E}  // '9'
};

const uint8_t font5x7_letters[26][5] = {
    {0x7E, 0x11, 0x11, 0x11, 0x7E}, // A
    {0x7F, 0x49, 0x49, 0x49, 0x36}, // B
    {0x3E, 0x41, 0x41, 0x41, 0x22}, // C
    {0x7F, 0x41, 0x41, 0x22, 0x1C}, // D
    {0x7F, 0x49, 0x49, 0x49, 0x41}, // E
    {0x7F, 0x09, 0x09, 0x09, 0x01}, // F
    {0x3E, 0x41, 0x49, 0x49, 0x7A}, // G
    {0x7F, 0x08, 0x08, 0x08, 0x7F}, // H
    {0x00, 0x41, 0x7F, 0x41, 0x00}, // I
    {0x20, 0x40, 0x41, 0x3F, 0x01}, // J
    {0x7F, 0x08, 0x14, 0x22, 0x41}, // K
    {0x7F, 0x40, 0x40, 0x40, 0x40}, // L
    {0x7F, 0x02, 0x0C, 0x02, 0x7F}, // M
    {0x7F, 0x04, 0x08, 0x10, 0x7F}, // N
    {0x3E, 0x41, 0x41, 0x41, 0x3E}, // O
    {0x7F, 0x09, 0x09, 0x09, 0x06}, // P
    {0x3E, 0x41, 0x51, 0x21, 0x5E}, // Q
    {0x7F, 0x09, 0x19, 0x29, 0x46}, // R
    {0x46, 0x49, 0x49, 0x49, 0x31}, // S
    {0x01, 0x01, 0x7F, 0x01, 0x01}, // T
    {0x3F, 0x40, 0x40, 0x40, 0x3F}, // U
    {0x1F, 0x20, 0x40, 0x20, 0x1F}, // V
    {0x7F, 0x20, 0x18, 0x20, 0x7F}, // W
    {0x63, 0x14, 0x08, 0x14, 0x63}, // X
    {0x07, 0x08, 0x70, 0x08, 0x07}, // Y
    {0x61, 0x51, 0x49, 0x45, 0x43}  // Z
};

// TODO : for this larger bit map , digit does not look good , have to work on it.
//const uint8_t large_digit_16x24[10][48] = {
//    // '0'
//    {
//        0x00,0xF8,0xFC,0x0E,0x06,0x06,0x06,0x06,0x06,0x06,0x0E,0xFC,0xF8,0x00,0x00,0x00,
//        0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,
//        0x00,0x1F,0x3F,0x70,0x60,0x60,0x60,0x60,0x60,0x60,0x70,0x3F,0x1F,0x00,0x00,0x00
//    },
//    // '1'
//    {
//        0x00,0x00,0x18,0x1C,0x0E,0x0E,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//        0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//        0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
//    },
//    // '2'
//    {
//        0x00,0xF8,0xFC,0x0E,0x06,0x06,0x06,0x06,0x0E,0x1C,0x38,0xF0,0xE0,0x00,0x00,0x00,
//        0x00,0xFF,0xFF,0x03,0x07,0x0E,0x1C,0x38,0x70,0x60,0xC0,0xFF,0xFF,0x00,0x00,0x00,
//        0x00,0x60,0x70,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,0x00,0x00
//    },
//    // '3'
//    {
//        0x00,0x38,0x7C,0x46,0x06,0x06,0x06,0x06,0x0E,0x1C,0xFC,0xF0,0x00,0x00,0x00,0x00,
//        0x00,0x1C,0x3C,0x30,0x30,0x30,0x30,0x30,0x38,0x3C,0xFF,0xCF,0x00,0x00,0x00,0x00,
//        0x00,0x18,0x38,0x70,0x60,0x60,0x60,0x60,0x60,0x70,0x7F,0x3F,0x00,0x00,0x00,0x00
//    },
//    // '4'
//    {
//        0x00,0x00,0x80,0xC0,0xF0,0x7C,0x1E,0x0F,0x07,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,
//        0x00,0x0F,0x0F,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0xFF,0xFF,0x0C,0x0C,0x0C,0x00,0x00,
//        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x7F,0x00,0x00,0x00,0x00,0x00
//    },
//    // '5'
//    {
//        0x00,0xFE,0xFE,0x0E,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x00,0x00,0x00,0x00,
//        0x00,0x3F,0x3F,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00,
//        0x00,0x18,0x38,0x70,0x60,0x60,0x60,0x60,0x60,0x70,0x7F,0x3F,0x00,0x00,0x00,0x00
//    },
//    // '6'
//    {
//        0x00,0xF0,0xF8,0x1C,0x0E,0x06,0x06,0x06,0x06,0x0E,0x1C,0x18,0x00,0x00,0x00,0x00,
//        0x00,0xFF,0xFF,0x30,0x30,0x30,0x30,0x30,0x30,0x38,0x1F,0x0F,0x00,0x00,0x00,0x00,
//        0x00,0x1F,0x3F,0x70,0x60,0x60,0x60,0x60,0x60,0x70,0x3F,0x1F,0x00,0x00,0x00,0x00
//    },
//    // '7'
//    {
//        0x00,0x0E,0x0E,0x06,0x06,0x06,0x06,0x06,0xC6,0xF6,0x7E,0x1E,0x00,0x00,0x00,0x00,
//        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,
//        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x7F,0x00,0x00,0x00,0x00,0x00
//    },
//    // '8'
//    {
//        0x00,0xF0,0xF8,0x1C,0x0E,0x06,0x06,0x06,0x06,0x0E,0x1C,0xF8,0xF0,0x00,0x00,0x00,
//        0x00,0xCF,0xDF,0x38,0x30,0x30,0x30,0x30,0x30,0x38,0x3C,0xFF,0xC7,0x00,0x00,0x00,
//        0x00,0x3F,0x7F,0x70,0x60,0x60,0x60,0x60,0x60,0x70,0x7F,0x3F,0x00,0x00,0x00,0x00
//    },
//    // '9'
//    {
//        0x00,0xF0,0xF8,0x1C,0x0E,0x06,0x06,0x06,0x06,0x0E,0x1C,0xF8,0xF0,0x00,0x00,0x00,
//        0x00,0xC7,0xCF,0x1C,0x18,0x18,0x18,0x18,0x18,0x9C,0xFE,0xFF,0x00,0x00,0x00,0x00,
//        0x00,0x18,0x38,0x70,0x60,0x60,0x60,0x60,0x60,0x70,0x7F,0x3F,0x00,0x00,0x00,0x00
//    }
//};



void write_command(uint8_t cmd) {
    OLED_CS_LOW;
    DC_CMD;
    spi_send(cmd,USART0);
    OLED_CS_HIGH;
}


void write_data(uint8_t data) {
    OLED_CS_LOW;
    DC_DATA;
    spi_send(data,USART0);
    OLED_CS_HIGH;

}

void oled_reset(void) {
    // As per ssd1306, min delay of 3 micro seconds needed after RES_LOW ( Page:27, Section: 8.9 )
    RES_LOW;
    DELAY_MICRO_SECS(5);
    RES_HIGH;
    DELAY_MICRO_SECS(5);
}

void oled_init(void) {
    oled_reset();
    // As per 1306 , min delay of 100 ms needed after reset so that SEG and COM will be active
    DELAY_MILLI_SECS(100);

    write_command(0xAE); // Display OFF
    write_command(0xD5); write_command(0x80); // Set clock
    write_command(0xA8); write_command(0x3F); // Multiplex = 64
    write_command(0xD3); write_command(0x00); // Display offset = 0
    write_command(0x40); // Start line = 0
    write_command(0x8D); write_command(0x14); // Charge pump ON
    write_command(0x20); write_command(0x00); // Horizontal addressing
    write_command(0xA1); // Segment remap (horizontal flip)
    write_command(0xC8); // COM scan direction (vertical flip)
    write_command(0xDA); write_command(0x12); // COM pins config
    write_command(0x81); write_command(0x7F); // Contrast
    write_command(0xD9); write_command(0xF1); // Pre-charge
    write_command(0xDB); write_command(0x40); // VCOM deselect
    write_command(0xA4); // Resume RAM display
    write_command(0xA6); // Normal display mode
//    oled_clear();
    write_command(0xAF); // Display ON
}

void oled_clear(void) {
        uint8_t page;
        uint8_t col;

        // As in horizontal addressing mode , column address pointer incremented to 1 when read/write at the current address and reset to 0 when column pointer reaches the end
        // similarly , page address pointer is incremented to 1 when the whole page is read/write and reset to 0 when it reaches the end.
        write_command(0xB0  );  // Set page address
        write_command(0x00);         // Lower column start
        write_command(0x10);         // Higher column start
        for (page = 0; page < 8; page++) {
            for (col= 0; col < 128; col++) {
                write_data(0x00);        // All pixels OFF
            }

        }
}

void oled_shutdown(void)
{
    write_command(0xAE);

}

void oled_test_pattern(void) {
    uint8_t page;
    uint8_t col;

    write_command(0xB0);
    write_command(0x00);
    write_command(0x10);

    for (page = 0; page < 8; page++) {

        for (col = 0; col < 128; col++) {
            write_data((col % 10) ? 0xFF : 0x00); // Stripe pattern // here observed 1 for black and 0 for light
        }
    }
}

//void oled_draw_large_digit(uint8_t digit, uint8_t start_page, uint8_t start_column) {
//    if (digit > 9) return;
//
//    const uint8_t* digit_data = large_digit_16x24[digit];
//
//    uint8_t page_offset;
//    for (page_offset = 0; page_offset < 3; page_offset++) {
//        uint8_t page = start_page + page_offset;
//
//        // Set page
//        write_command(0xB0 | page);
//
//        // Set column address
//        write_command(start_column & 0x0F);                  // Lower nibble
//        write_command(0x10 | ((start_column >> 4) & 0x0F));  // Upper nibble
//
//        // Write 16 columns of font data for this page
//        uint8_t col;
//        for (col = 0; col < 16; col++) {
//            write_data(digit_data[page_offset * 16 + col]);
//        }
//    }
//
//    // Optional: add a space column (1 column space after the digit)
//    write_command(0xB0 | start_page);                        // Back to first page
//    write_command((start_column + 16) & 0x0F);               // Lower nibble
//    write_command(0x10 | (((start_column + 16) >> 4) & 0x0F)); // Upper nibble
//    write_data(0x00); // 1-column space
//}

// handles multi digit int data
void oled_draw_digits(uint16_t digit , uint8_t *page , uint8_t*column,uint8_t* n_digits)
{
   // TODO :VLA is not supported
    // as VLA is not supported ,used fixed sized arr to split the digits
    uint8_t digit_arr[7] = {0,0,0,0,0,0,0};
    convert_digit_to_array(digit,digit_arr,0,n_digits);

    uint8_t col_off  = (uint8_t)(*n_digits/2);

    *column = mid_col - (pixel_per_digit*col_off);
    *page = init_page;

    uint8_t i;
    for(i=0;i<*n_digits;i++)
    {
        // each digit will take up 7 columns
        oled_draw_digit(digit_arr[i],*page,*column+(i*7));
    }

}

void oled_draw_char(uint8_t char_pos,uint8_t page, uint8_t column)
{
    // Set page
      write_command(0xB0 + page);

      // Set column address
      write_command(column & 0x0F);             // Lower nibble
      write_command(0x10 | ((column >> 4) & 0x0F)); // Upper nibble

      uint8_t i;
      // Send font bytes
      for (i = 0; i < 5; i++) {
          write_data(font5x7_letters[char_pos][i]);
      }

      write_data(0x00); // 1-column space
      write_data(0x00); // 1-column space

}

void oled_draw_digit(uint8_t digit, uint8_t page, uint8_t column) {
    uint8_t i;
    if (digit > 9) return;

    // Set page
    write_command(0xB0 + page);

    // Set column address
    write_command(column & 0x0F);             // Lower nibble
    write_command(0x10 | ((column >> 4) & 0x0F)); // Upper nibble

    // Send font bytes
    for (i = 0; i < 5; i++) {
        write_data(font5x7_digits[digit][i]);
    }

    write_data(0x00); // 1-column space
    write_data(0x00); // 1-column space
}

void oled_clear_digit(uint8_t page, uint8_t column) {

    //Set page
    write_command(0xB0 + page);

    // Set column address
    write_command(column & 0x0F);             // Lower nibble
    write_command(0x10 | ((column >> 4) & 0x0F)); // Upper nibble

    // Send font bytes
    uint8_t i ;
    for (i = 0; i < 5; i++) {
        write_data(0x00);
    }
}

void oled_clear_digits(uint8_t *page, uint8_t *column,uint8_t *n_digits,uint8_t clear_count) {

    //Set page
    write_command(0xB0 + *page);

    // Set column address
    write_command(*column & 0x0F);             // Lower nibble
    write_command(0x10 | ((*column >> 4) & 0x0F)); // Upper nibble

    // Send font bytes
    uint8_t i ;
    uint8_t j ;
    for(i=0;i<clear_count;i++)
    {
        for (j = 0; j < 5; j++) {
            write_data(0x00);
        }
        *column = *column + pixel_per_digit;
        // Set column address
        write_command(*column & 0x0F);             // Lower nibble
        write_command(0x10 | ((*column >> 4) & 0x0F)); // Upper nibble
        *n_digits-=1;
    }
}

// len defines the width of the data should be displayed
// eg: 10 , width = 4 , final_value= [0,0,1,0]
// eg: 10 , width = 0 , final_value = [1,0]

void convert_digit_to_array(uint16_t data , uint8_t* digits,uint8_t width,uint8_t* n_digits)
{

      uint16_t temp = data;
      uint8_t count = 0;

      // extracting individual digit in reverse order
      while (temp > 0) {
          digits[count++] = temp % 10;
          temp /= 10;
      }

      if(width!=0)
      {
          while(count <= (width-1))
          {
              digits[count++] = 0;
          }
      }

      uint8_t i ;
      // Now reverse the array to get digits in correct order
      for (i = 0; i < count / 2; i++) {
          int t = digits[i];
          digits[i] = digits[count - 1 - i];
          digits[count - 1 - i] = t;
      }

      *n_digits = count;
}

// handles decimal data
//void oled_put_data(float data,uint8_t page , uint8_t start_col)
//{
//    uint8_t int_digit[4];
//    uint8_t decimal_digit[2];
//
//    int int_part = (int)data;
//    int decimal_part = (int)((data - int_part)*100);
//
//    if(decimal_part < 0 ) decimal_part = -decimal_part;
//
//    // drawing int part
//
//    convert_digit_to_array(int_part,int_digit,4);
//
//    uint8_t i;
//    for ( i = 0;i<4;i++)
//    {
//        oled_draw_digit(int_digit[i],page,start_col+(i*7));
//    }
//
//    write_data(0xFF);
//    write_data(0x00);
//    ///
//
//    // drawing decimal part
//    convert_digit_to_array(decimal_part,decimal_digit,2);
//
//    start_col = start_col + 30;
//
//    for (i = 0;i<2;i++)
//    {
//       oled_draw_digit(decimal_digit[i],page,start_col+(i*7));
//    }
//    ////
//
//}
//
